// Generated by CoffeeScript 1.10.0
(function() {
  var CWD, _settings, abs, exec, fs, isGitProject, nodemiral, path, reapplyMeteorSettings, url;

  fs = require('fs');

  exec = require('child_process').exec;

  path = require('path');

  nodemiral = require('nodemiral');

  url = require('url');

  abs = require('abs');

  _settings = require('./settings');

  CWD = process.cwd();

  isGitProject = function(pm2mConf) {
    if (!pm2mConf.appLocation.local || pm2mConf.appLocation.local.trim() === "") {
      return true;
    } else {
      return false;
    }
  };

  reapplyMeteorSettings = function(pm2mConf) {
    var err, error, meteorSettingsLocation, meteorSettingsObj, pm2EnvLocation, pm2EnvObj, prettyJson;
    if (isGitProject(pm2mConf)) {
      if (pm2mConf.meteorSettingsLocation && pm2mConf.meteorSettingsLocation !== "") {
        meteorSettingsObj = {};
        meteorSettingsLocation = path.join(CWD, _settings.gitDirName, pm2mConf.meteorSettingsLocation);
        pm2EnvLocation = path.join(CWD, _settings.pm2EnvConfigName);
        meteorSettingsObj = require(meteorSettingsLocation);
        pm2EnvObj = require(pm2EnvLocation);
        pm2EnvObj.apps[0].env["METEOR_SETTINGS"] = meteorSettingsObj;
        prettyJson = JSON.stringify(pm2EnvObj, null, 2);
        try {
          return fs.writeFileSync(_settings.pm2EnvConfigName, prettyJson);
        } catch (error) {
          err = error;
          console.log("Couldn't update " + _settings.pm2EnvConfigName + " with Meteor Settings");
          console.log(err.message);
          return process.exit(1);
        }
      }
    }
  };

  module.exports = {
    initPM2MeteorSettings: function(done) {
      var err, error, json, prettyJson;
      json = _settings.pm2MeteorConfigTemplate;
      prettyJson = JSON.stringify(json, null, 2);
      try {
        fs.writeFileSync(_settings.pm2MeteorConfigName, prettyJson);
      } catch (error) {
        err = error;
        done(err);
      }
      return done();
    },
    generatePM2EnvironmentSettings: function(pm2mConf, done) {
      var appJson, envJson, err, error, error1, meteorSettingsLocation, meteorSettingsObj, prettyJson;
      envJson = _settings.pm2EnvConfigTemplate;
      appJson = {};
      appJson.name = pm2mConf.appName;
      appJson.env = pm2mConf.env;
      appJson.script = path.join(pm2mConf.server.deploymentDir, pm2mConf.appName, "bundle/main.js");
      appJson.exec_mode = pm2mConf.server.exec_mode;
      appJson.instances = pm2mConf.server.instances;
      meteorSettingsObj = {};
      if (!isGitProject(pm2mConf)) {
        if (pm2mConf.meteorSettingsLocation) {
          try {
            meteorSettingsLocation = abs(pm2mConf.meteorSettingsLocation);
            meteorSettingsObj = JSON.parse(fs.readFileSync(meteorSettingsLocation, 'utf8'));
          } catch (error) {
            err = error;
            done(err);
          }
        }
      }
      appJson.env["METEOR_SETTINGS"] = meteorSettingsObj;
      envJson.apps.push(appJson);
      prettyJson = JSON.stringify(envJson, null, 2);
      try {
        fs.writeFileSync(_settings.pm2EnvConfigName, prettyJson);
      } catch (error1) {
        err = error1;
        done({
          message: "" + err.message
        });
      }
      return done();
    },
    bundleApplication: function(pm2mConf, done) {
      return exec("cd " + (abs(pm2mConf.appLocation.local)) + " && meteor build " + pm2mConf.meteorBuildFlags + " --directory " + CWD, function(err, stdout, stderr) {
        if (err) {
          return done(err);
        } else {
          return exec("cd " + CWD + " && tar -zcvf " + _settings.bundleTarName + " " + _settings.bundleName + " " + _settings.pm2EnvConfigName, {
            maxBuffer: 1024 * 200000
          }, function(err, stdout, stderr) {
            if (err) {
              return done(err);
            } else {
              return done();
            }
          });
        }
      });
    },
    bundleApplicationFromGit: function(pm2mConf, done) {
      return exec("cd " + CWD + " && git clone " + pm2mConf.appLocation.git + " --branch " + pm2mConf.appLocation.branch + " " + _settings.gitDirName, function(err, stdout, stderr) {
        if (err) {
          return done(err);
        } else {
          reapplyMeteorSettings(pm2mConf);
          return exec("cd " + (path.join(CWD, _settings.gitDirName)) + " && meteor build " + pm2mConf.meteorBuildFlags + " --directory " + CWD, function(err, sdout, stderr) {
            if (err) {
              return done(err);
            } else {
              return exec("cd " + CWD + " && tar -zcvf " + _settings.bundleTarName + " " + _settings.bundleName + " " + _settings.pm2EnvConfigName, {
                maxBuffer: 1024 * 200000
              }, function(err, stdout, stderr) {
                if (err) {
                  return done(err);
                } else {
                  return done();
                }
              });
            }
          });
        }
      });
    },
    makeClean: function(done) {
      return exec("cd " + CWD + " && rm -rf " + _settings.bundleName + " && rm " + _settings.pm2EnvConfigName + " && rm " + _settings.bundleTarName + " && rm -rf " + _settings.gitDirName, function(err, stdout, stderr) {
        if (err) {
          return done(err);
        } else {
          return done();
        }
      });
    }
  };

}).call(this);
